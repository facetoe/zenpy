
######################################################################
#  Do not modify, these classes are autogenerated by gen_classes.py  #
######################################################################

import json
import dateutil.parser
from zenpy.lib.util import json_encode_for_printing, json_encode_for_zendesk


class BaseObject(object):
    """
    Base for all Zenpy objects. Keeps track of which attributes have been modified.
    """

    def __new__(cls, *args, **kwargs):
        instance = super(BaseObject, cls).__new__(cls)
        instance.__dict__['_dirty_attributes'] = set()
        instance.__dict__['_dirty_callback'] = None
        instance.__dict__['_always_dirty'] = set()
        return instance

    def __setattr__(self, key, value):
        if key not in ('_dirty', '_dirty_callback', '_always_dirty'):
            self.__dict__['_dirty_attributes'].add(key)
            if self._dirty_callback is not None:
                self._dirty_callback()
        object.__setattr__(self, key, value)

    def _clean_dirty(self, obj=None):
        """ Recursively clean self and all child objects. """
        obj = obj or self
        obj.__dict__['_dirty_attributes'].clear()
        obj._dirty = False
        for key, val in vars(obj).items():
            if isinstance(val, BaseObject):
                self._clean_dirty(val)
            else:
                func = getattr(val, '_clean_dirty', None)
                if callable(func):
                    func()

    def _set_dirty(self, obj=None):
        """ Recursively set self and all child objects _dirty flag. """
        obj = obj or self
        for key, value in vars(obj).items():
            if key not in ('api', '_dirty_attributes', '_always_dirty', '_dirty_callback', '_dirty'):
                setattr(obj, key, value)
                if isinstance(value, BaseObject):
                    self._set_dirty(value)

    def to_json(self, indent=2):
        """ Return self formatted as JSON. """
        return json.dumps(self, default=json_encode_for_printing, indent=indent)

    def to_dict(self, serialize=False):
        """
        This method returns the object as a Python dict. If serialize is passed, only those attributes
        that have been modified will be included in the result.
        """
        if serialize:
            encode_method = json_encode_for_zendesk
        else:
            encode_method = json_encode_for_printing
        return json.loads(json.dumps(self._to_dict(serialize=serialize), default=encode_method))

    def _to_dict(self, serialize=False):
        """
        This method works by copying self.__dict__, and removing everything that should not be serialized.
        """
        copy_dict = self.__dict__.copy()
        for key, value in vars(self).items():
            # We want to send all ids to Zendesk always
            if serialize and key == 'id':
                continue

            # If this is a Zenpy object, convert it to a dict.
            if not serialize and isinstance(value, BaseObject):
                copy_dict[key] = copy_dict.pop(key).to_dict()

            # This object has a flag indicating it has been dirtied, so we want to send it off.
            elif serialize and getattr(value, '_dirty', False):
                continue

            # Here we have an attribute that should always be sent to Zendesk.
            elif serialize and key in self._always_dirty:
                continue

            # These are for internal tracking, so just delete.
            elif key in ('api', '_dirty_attributes', '_always_dirty', '_dirty_callback', '_dirty'):
                del copy_dict[key]

            # If the attribute has not been modified, do not send it.
            elif serialize and key not in self._dirty_attributes:
                del copy_dict[key]

            # Some reserved words are prefixed with an underscore, remove it here.
            elif key.startswith('_'):
                copy_dict[key[1:]] = copy_dict[key]
                del copy_dict[key]
        return copy_dict

    def __repr__(self):
        class_name = type(self).__name__
        if class_name in ('UserField',):
            return "{}()".format(class_name)

        def formatted(item):
            return item if (isinstance(item, int) or item is None) else "'{}'".format(item)

        for identifier in ('id', 'token', 'key', 'name', 'account_key'):
            if hasattr(self, identifier):
                return "{}({}={})".format(class_name, identifier, formatted(getattr(self, identifier)))
        return "{}()".format(class_name)


class Activity(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 actor=None,
                 created_at=None,
                 id=None,
                 title=None,
                 updated_at=None,
                 url=None,
                 user=None,
                 verb=None,
                 **kwargs):

        self.api = api
        self.actor = actor
        self.created_at = created_at
        self.id = id
        self.title = title
        self.updated_at = updated_at
        self.url = url
        self.user = user
        self.verb = verb

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class AgentMacroReference(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 id=None,
                 macro_id=None,
                 macro_title=None,
                 type=None,
                 via=None,
                 **kwargs):

        self.api = api
        self.id = id
        self.macro_id = macro_id
        self.macro_title = macro_title
        self.type = type
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def macro(self):

        if self.api and self.macro_id:
            return self.api._get_macro(self.macro_id)

    @macro.setter
    def macro(self, macro):
        if macro:
            self.macro_id = macro.id
            self._macro = macro


class Attachment(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 content_type=None,
                 content_url=None,
                 file_name=None,
                 id=None,
                 size=None,
                 thumbnails=None,
                 **kwargs):

        self.api = api

        # Comment: The content type of the image. Example value: image/png
        # Read-only: yes
        # Type: string
        self.content_type = content_type

        # Comment: A full URL where the attachment image file can be downloaded
        # Read-only: yes
        # Type: string
        self.content_url = content_url

        # Comment: The name of the image file
        # Read-only: yes
        # Type: string
        self.file_name = file_name

        # Comment: Automatically assigned when created
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The size of the image file in bytes
        # Read-only: yes
        # Type: integer
        self.size = size

        # Comment: An array of Photo objects. Note that thumbnails do not have thumbnails.
        # Read-only: yes
        # Type: array
        self.thumbnails = thumbnails

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Audit(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 author_id=None,
                 created_at=None,
                 events=None,
                 id=None,
                 metadata=None,
                 ticket_id=None,
                 via=None,
                 **kwargs):

        self.api = api
        self.author_id = author_id
        self.created_at = created_at
        self.events = events
        self.id = id
        self.metadata = metadata
        self.ticket_id = ticket_id
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def author(self):

        if self.api and self.author_id:
            return self.api._get_user(self.author_id)

    @author.setter
    def author(self, author):
        if author:
            self.author_id = author.id
            self._author = author

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def ticket(self):

        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket


class Automation(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 actions=None,
                 active=None,
                 conditions=None,
                 created_at=None,
                 id=None,
                 position=None,
                 raw_title=None,
                 title=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: An object describing what the automation will do
        # Type: :class:`Actions`
        self.actions = actions

        # Comment: Whether the automation is active
        # Type: boolean
        self.active = active

        # Comment: An object that describes the conditions under which the automation will execute
        # Type: :class:`Conditions`
        self.conditions = conditions

        # Comment: The time the automation was created
        # Type: date
        self.created_at = created_at

        # Comment: Automatically assigned when created
        # Type: integer
        self.id = id

        # Comment: Position of the automation, determines the order they will execute in
        # Type: integer
        self.position = position
        self.raw_title = raw_title

        # Comment: The title of the automation
        # Type: string
        self.title = title

        # Comment: The time of the last update of the automation
        # Type: date
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the automation was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the automation
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Brand(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 brand_url=None,
                 created_at=None,
                 default=None,
                 has_help_center=None,
                 help_center_state=None,
                 host_mapping=None,
                 id=None,
                 logo=None,
                 name=None,
                 subdomain=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: If the brand is set as active
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.active = active

        # Comment: The url of the brand
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.brand_url = brand_url

        # Comment: The time the brand was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: Is the brand the default brand for this account
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.default = default

        # Comment: If the brand has a Help Center
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.has_help_center = has_help_center

        # Comment: The state of the Help Center: enabled, disabled, or restricted
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.help_center_state = help_center_state

        # Comment: The hostmapping to this brand, if any (only admins view this key)
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.host_mapping = host_mapping

        # Comment: Automatically assigned when the brand is created
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: Logo image for this brand
        # Mandatory: no
        # Read-only: no
        # Type: :class:`Attachment`
        self.logo = logo

        # Comment: The name of the brand
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.name = name

        # Comment: The subdomain of the brand
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.subdomain = subdomain

        # Comment: The time of the last update of the brand
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this brand
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the brand was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the brand
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class CcEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 id=None,
                 recipients=None,
                 type=None,
                 via=None,
                 **kwargs):

        self.api = api
        self.id = id
        self.recipients = recipients
        self.type = type
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class ChangeEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 field_name=None,
                 id=None,
                 previous_value=None,
                 type=None,
                 value=None,
                 **kwargs):

        self.api = api
        self.field_name = field_name
        self.id = id
        self.previous_value = previous_value
        self.type = type
        self.value = value

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Comment(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 attachments=None,
                 author_id=None,
                 body=None,
                 created_at=None,
                 id=None,
                 metadata=None,
                 public=None,
                 type=None,
                 via=None,
                 **kwargs):

        self.api = api
        self.attachments = attachments
        self.author_id = author_id
        self.body = body
        self.created_at = created_at
        self.id = id
        self.metadata = metadata
        self.public = public
        self.type = type
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def author(self):

        if self.api and self.author_id:
            return self.api._get_user(self.author_id)

    @author.setter
    def author(self, author):
        if author:
            self.author_id = author.id
            self._author = author

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created


class CommentPrivacyChangeEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 comment_id=None,
                 id=None,
                 public=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.comment_id = comment_id
        self.id = id
        self.public = public
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def comment(self):

        if self.api and self.comment_id:
            return self.api._get_comment(self.comment_id)

    @comment.setter
    def comment(self, comment):
        if comment:
            self.comment_id = comment.id
            self._comment = comment


class Conditions(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, all=None, any=None, **kwargs):

        self.api = api
        self.all = all
        self.any = any

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class CreateEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 field_name=None,
                 id=None,
                 type=None,
                 value=None,
                 **kwargs):

        self.api = api
        self.field_name = field_name
        self.id = id
        self.type = type
        self.value = value

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class CustomAgentRole(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 configuration=None,
                 created_at=None,
                 description=None,
                 id=None,
                 name=None,
                 role_type=None,
                 updated_at=None,
                 **kwargs):

        self.api = api
        self.configuration = configuration
        self.created_at = created_at
        self.description = description
        self.id = id
        self.name = name
        self.role_type = role_type
        self.updated_at = updated_at

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class CustomField(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, id=None, value=None, **kwargs):

        self.api = api
        self.id = id
        self.value = value

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class CustomFieldOption(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 id=None,
                 name=None,
                 position=None,
                 raw_name=None,
                 url=None,
                 value=None,
                 **kwargs):

        self.api = api
        self.id = id
        self.name = name
        self.position = position
        self.raw_name = raw_name
        self.url = url
        self.value = value

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Definitions(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, all=None, any=None, **kwargs):

        self.api = api
        self.all = all
        self.any = any

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class ErrorEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, id=None, message=None, type=None, **kwargs):

        self.api = api
        self.id = id
        self.message = message
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Export(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, status=None, view_id=None, **kwargs):

        self.api = api
        self.status = status
        self.view_id = view_id

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def view(self):

        if self.api and self.view_id:
            return self.api._get_view(self.view_id)

    @view.setter
    def view(self, view):
        if view:
            self.view_id = view.id
            self._view = view


class ExternalEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 body=None,
                 id=None,
                 resource=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.body = body
        self.id = id
        self.resource = resource
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class FacebookCommentEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 attachments=None,
                 author_id=None,
                 body=None,
                 data=None,
                 graph_object_id=None,
                 html_body=None,
                 id=None,
                 public=None,
                 trusted=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.attachments = attachments
        self.author_id = author_id
        self.body = body
        self.data = data
        self.graph_object_id = graph_object_id
        self.html_body = html_body
        self.id = id
        self.public = public
        self.trusted = trusted
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def author(self):

        if self.api and self.author_id:
            return self.api._get_user(self.author_id)

    @author.setter
    def author(self, author):
        if author:
            self.author_id = author.id
            self._author = author


class FacebookEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 body=None,
                 communication=None,
                 id=None,
                 page=None,
                 ticket_via=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.body = body
        self.communication = communication
        self.id = id
        self.page = page
        self.ticket_via = ticket_via
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Group(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 deleted=None,
                 id=None,
                 name=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: The time the group was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: Deleted groups get marked as such
        # Mandatory: no
        # Read-only: yes
        # Type: boolean
        self.deleted = deleted

        # Comment: Automatically assigned when creating groups
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The name of the group
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.name = name

        # Comment: The time of the last update of the group
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this group
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the group was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the group
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class GroupMembership(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 default=None,
                 group_id=None,
                 id=None,
                 updated_at=None,
                 url=None,
                 user_id=None,
                 **kwargs):

        self.api = api

        # Comment: The time the membership was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: If true, tickets assigned directly to the agent will assume this membership's group.
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.default = default

        # Comment: The id of a group
        # Mandatory: yes
        # Read-only: no
        # Type: integer
        self.group_id = group_id

        # Comment: Automatically assigned upon creation
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The time of the last update of the membership
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this record
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        # Comment: The id of an agent
        # Mandatory: yes
        # Read-only: no
        # Type: integer
        self.user_id = user_id

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the membership was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def group(self):
        """
        |  Comment: The id of a group
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the membership
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def user(self):
        """
        |  Comment: The id of an agent
        """
        if self.api and self.user_id:
            return self.api._get_user(self.user_id)

    @user.setter
    def user(self, user):
        if user:
            self.user_id = user.id
            self._user = user


class Identity(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 deliverable_state=None,
                 id=None,
                 primary=None,
                 type=None,
                 undeliverable_count=None,
                 updated_at=None,
                 url=None,
                 user_id=None,
                 value=None,
                 verified=None,
                 **kwargs):

        self.api = api
        self.created_at = created_at
        self.deliverable_state = deliverable_state
        self.id = id
        self.primary = primary
        self.type = type
        self.undeliverable_count = undeliverable_count
        self.updated_at = updated_at
        self.url = url
        self.user_id = user_id
        self.value = value
        self.verified = verified

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def user(self):

        if self.api and self.user_id:
            return self.api._get_user(self.user_id)

    @user.setter
    def user(self, user):
        if user:
            self.user_id = user.id
            self._user = user


class Item(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 default_locale_id=None,
                 id=None,
                 name=None,
                 outdated=None,
                 placeholder=None,
                 updated_at=None,
                 url=None,
                 variants=None,
                 **kwargs):

        self.api = api
        self.created_at = created_at
        self.default_locale_id = default_locale_id
        self.id = id
        self.name = name
        self.outdated = outdated
        self.placeholder = placeholder
        self.updated_at = updated_at
        self.url = url
        self.variants = variants

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def default_locale(self):

        if self.api and self.default_locale_id:
            return self.api._get_default_locale(self.default_locale_id)

    @default_locale.setter
    def default_locale(self, default_locale):
        if default_locale:
            self.default_locale_id = default_locale.id
            self._default_locale = default_locale

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class JobStatus(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 id=None,
                 message=None,
                 progress=None,
                 results=None,
                 status=None,
                 total=None,
                 url=None,
                 **kwargs):

        self.api = api
        self.id = id
        self.message = message
        self.progress = progress
        self.results = results
        self.status = status
        self.total = total
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class JobStatusResult(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 action=None,
                 errors=None,
                 id=None,
                 status=None,
                 success=None,
                 title=None,
                 **kwargs):

        self.api = api
        self.action = action
        self.errors = errors
        self.id = id
        self.status = status
        self.success = success
        self.title = title

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Link(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 id=None,
                 issue_id=None,
                 issue_key=None,
                 ticket_id=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api
        self.created_at = created_at
        self.id = id
        self.issue_id = issue_id
        self.issue_key = issue_key
        self.ticket_id = ticket_id
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def ticket(self):

        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Locale(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 default=None,
                 id=None,
                 locale=None,
                 name=None,
                 native_name=None,
                 presentation_name=None,
                 rtl=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api
        self.created_at = created_at
        self.default = default

        # Description: Either the ID or the bcp-47 code of the locale (es-419, en-us, pr-br)
        # Type: string
        self.id = id
        self.locale = locale
        self.name = name
        self.native_name = native_name
        self.presentation_name = presentation_name
        self.rtl = rtl
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class LogmeinTranscriptEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, body=None, id=None, type=None, **kwargs):

        self.api = api
        self.body = body
        self.id = id
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Macro(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 actions=None,
                 active=None,
                 created_at=None,
                 description=None,
                 id=None,
                 position=None,
                 restriction=None,
                 title=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: An object describing what the macro will do
        # Type: :class:`Actions`
        self.actions = actions

        # Comment: Useful for determining if the macro should be displayed
        # Type: boolean
        self.active = active

        # Comment: The time the macro was created
        # Type: date
        self.created_at = created_at

        # Comment: The description of the macro
        # Type: string
        self.description = description

        # Comment: Automatically assigned when created
        # Type: integer
        self.id = id

        # Comment: The position of the macro
        # Type: integer
        self.position = position

        # Comment: Who may access this macro. Will be null when everyone in the account can access it
        # Type: object
        self.restriction = restriction

        # Comment: The title of the macro
        # Type: string
        self.title = title

        # Comment: The time of the last update of the macro
        # Type: date
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the macro was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the macro
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class MacroResult(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, ticket=None, **kwargs):

        self.api = api
        self.ticket = ticket

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Metadata(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, custom=None, system=None, **kwargs):

        self.api = api
        self.custom = custom
        self.system = system

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class NotificationEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 body=None,
                 id=None,
                 recipients=None,
                 subject=None,
                 type=None,
                 via=None,
                 **kwargs):

        self.api = api
        self.body = body
        self.id = id
        self.recipients = recipients
        self.subject = subject
        self.type = type
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Organization(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 details=None,
                 domain_names=None,
                 external_id=None,
                 group_id=None,
                 id=None,
                 name=None,
                 notes=None,
                 organization_fields=None,
                 shared_comments=None,
                 shared_tickets=None,
                 tags=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: The time the organization was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: Any details obout the organization, such as the address
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.details = details

        # Comment: An array of domain names associated with this organization
        # Mandatory: no
        # Read-only: no
        # Type: array
        self.domain_names = domain_names

        # Comment: A unique external id to associate organizations to an external record
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.external_id = external_id

        # Comment: New tickets from users in this organization are automatically put in this group
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.group_id = group_id

        # Comment: Automatically assigned when the organization is created
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: A unique name for the organization
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.name = name

        # Comment: Any notes you have about the organization
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.notes = notes

        # Comment: Custom fields for this organization
        # Mandatory: no
        # Read-only: no
        # Type: :class:`hash`
        self.organization_fields = organization_fields

        # Comment: End users in this organization are able to see each other's comments on tickets
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.shared_comments = shared_comments

        # Comment: End users in this organization are able to see each other's tickets
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.shared_tickets = shared_tickets

        # Comment: The tags of the organization
        # Mandatory: no
        # Read-only: no
        # Type: array
        self.tags = tags

        # Comment: The time of the last update of the organization
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this organization
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the organization was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def group(self):
        """
        |  Comment: New tickets from users in this organization are automatically put in this group
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the organization
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class OrganizationActivityEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 body=None,
                 id=None,
                 recipients=None,
                 subject=None,
                 type=None,
                 via=None,
                 **kwargs):

        self.api = api
        self.body = body
        self.id = id
        self.recipients = recipients
        self.subject = subject
        self.type = type
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class OrganizationField(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 created_at=None,
                 description=None,
                 id=None,
                 key=None,
                 position=None,
                 raw_description=None,
                 raw_title=None,
                 regexp_for_validation=None,
                 title=None,
                 type=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: If true, this field is available for use
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.active = active

        # Comment: The time the ticket field was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: User-defined description of this field's purpose
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.description = description

        # Comment: Automatically assigned upon creation
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders.
        # Mandatory: on create
        # Read-only: no
        # Type: string
        self.key = key

        # Comment: Ordering of the field relative to other fields
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.position = position

        # Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_description = raw_description

        # Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_title = raw_title

        # Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.regexp_for_validation = regexp_for_validation

        # Comment: The title of the custom field
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.title = title

        # Comment: Type of the custom field: "checkbox", "date", "decimal", "dropdown", "integer", "regexp", "text", or "textarea"
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.type = type

        # Comment: The time of the last update of the ticket field
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The URL for this resource
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the ticket field was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the ticket field
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class OrganizationMembership(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 default=None,
                 id=None,
                 organization_id=None,
                 updated_at=None,
                 url=None,
                 user_id=None,
                 **kwargs):

        self.api = api

        # Comment: When this record was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: Denotes whether this is the default organization membership for the user. If false, returns null
        # Mandatory: yes
        # Read-only: no
        # Type: boolean
        self.default = default

        # Comment: Automatically assigned when the membership is created
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The ID of the organization associated with this user, in this membership
        # Mandatory: yes
        # Read-only: yes
        # Type: integer
        self.organization_id = organization_id

        # Comment: When this record last got updated
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this membership
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        # Comment: The ID of the user for whom this memberships belongs
        # Mandatory: yes
        # Read-only: yes
        # Type: integer
        self.user_id = user_id

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def organization(self):
        """
        |  Comment: The ID of the organization associated with this user, in this membership
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def user(self):
        """
        |  Comment: The ID of the user for whom this memberships belongs
        """
        if self.api and self.user_id:
            return self.api._get_user(self.user_id)

    @user.setter
    def user(self, user):
        if user:
            self.user_id = user.id
            self._user = user


class PolicyMetric(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 business_hours=None,
                 metric=None,
                 priority=None,
                 target=None,
                 **kwargs):

        self.api = api
        self.business_hours = business_hours
        self.metric = metric
        self.priority = priority
        self.target = target

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class PushEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 id=None,
                 type=None,
                 value=None,
                 value_reference=None,
                 **kwargs):

        self.api = api
        self.id = id
        self.type = type
        self.value = value
        self.value_reference = value_reference

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Recipient(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 delivered_at=None,
                 delivery_id=None,
                 id=None,
                 survey_id=None,
                 survey_name=None,
                 updated_at=None,
                 user_email=None,
                 user_id=None,
                 user_name=None,
                 **kwargs):

        self.api = api
        self.created_at = created_at
        self.delivered_at = delivered_at
        self.delivery_id = delivery_id
        self.id = id
        self.survey_id = survey_id
        self.survey_name = survey_name
        self.updated_at = updated_at
        self.user_email = user_email
        self.user_id = user_id
        self.user_name = user_name

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def delivered(self):

        if self.delivered_at:
            return dateutil.parser.parse(self.delivered_at)

    @delivered.setter
    def delivered(self, delivered):
        if delivered:
            self.delivered_at = delivered

    @property
    def delivery(self):

        if self.api and self.delivery_id:
            return self.api._get_delivery(self.delivery_id)

    @delivery.setter
    def delivery(self, delivery):
        if delivery:
            self.delivery_id = delivery.id
            self._delivery = delivery

    @property
    def survey(self):

        if self.api and self.survey_id:
            return self.api._get_survey(self.survey_id)

    @survey.setter
    def survey(self, survey):
        if survey:
            self.survey_id = survey.id
            self._survey = survey

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def user(self):

        if self.api and self.user_id:
            return self.api._get_user(self.user_id)

    @user.setter
    def user(self, user):
        if user:
            self.user_id = user.id
            self._user = user


class RecipientAddress(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 brand_id=None,
                 created_at=None,
                 default=None,
                 email=None,
                 forwarding_status=None,
                 id=None,
                 name=None,
                 spf_status=None,
                 updated_at=None,
                 **kwargs):

        self.api = api
        self.brand_id = brand_id
        self.created_at = created_at
        self.default = default
        self.email = email
        self.forwarding_status = forwarding_status
        self.id = id
        self.name = name
        self.spf_status = spf_status
        self.updated_at = updated_at

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def brand(self):

        if self.api and self.brand_id:
            return self.api._get_brand(self.brand_id)

    @brand.setter
    def brand(self, brand):
        if brand:
            self.brand_id = brand.id
            self._brand = brand

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Request(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 assignee_id=None,
                 can_be_solved_by_me=None,
                 collaborator_ids=None,
                 created_at=None,
                 custom_fields=None,
                 description=None,
                 due_at=None,
                 fields=None,
                 id=None,
                 organization_id=None,
                 priority=None,
                 requester_id=None,
                 status=None,
                 subject=None,
                 type=None,
                 updated_at=None,
                 url=None,
                 via=None,
                 **kwargs):

        self.api = api

        # Comment: The id of the assignee if the field is visible to end users
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.assignee_id = assignee_id

        # Comment: If true, end user can mark request as solved.
        # Mandatory: no
        # Read-only: yes
        # Type: boolean
        self.can_be_solved_by_me = can_be_solved_by_me

        # Comment: Who are currently CC'ed on the ticket
        # Mandatory: no
        # Read-only: yes
        # Type: array
        self.collaborator_ids = collaborator_ids

        # Comment: When this record was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: The fields and entries for this request
        # Mandatory: no
        # Read-only: no
        # Type: :class:`Array`
        self.custom_fields = custom_fields

        # Comment: The first comment on the request
        # Mandatory: yes
        # Read-only: yes
        # Type: string
        self.description = description

        # Comment: When the task is due (only applies if the request is of type "task")
        # Mandatory: no
        # Read-only: no
        # Type: date
        self.due_at = due_at
        self.fields = fields

        # Comment: Automatically assigned when creating requests
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The organization of the requester
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.organization_id = organization_id

        # Comment: The priority of the request, "low", "normal", "high", "urgent"
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.priority = priority

        # Comment: The id of the requester
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.requester_id = requester_id

        # Comment: The state of the request, "new", "open", "pending", "hold", "solved", "closed"
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.status = status

        # Comment: The value of the subject field for this request if the subject field is visible to end users; a truncated version of the description otherwise
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.subject = subject

        # Comment: The type of the request, "question", "incident", "problem", "task"
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.type = type

        # Comment: When this record last got updated
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this request
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        # Comment: This object explains how the request was created
        # Mandatory: no
        # Read-only: yes
        # Type: :class:`Via`
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def assignee(self):
        """
        |  Comment: The id of the assignee if the field is visible to end users
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)

    @assignee.setter
    def assignee(self, assignee):
        if assignee:
            self.assignee_id = assignee.id
            self._assignee = assignee

    @property
    def collaborators(self):
        """
        |  Comment: Who are currently CC'ed on the ticket
        """
        if self.api and self.collaborator_ids:
            return self.api._get_users(self.collaborator_ids)

    @collaborators.setter
    def collaborators(self, collaborators):
        if collaborators:
            self.collaborator_ids = [o.id for o in collaborators]
            self._collaborators = collaborators

    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def due(self):
        """
        |  Comment: When the task is due (only applies if the request is of type "task")
        """
        if self.due_at:
            return dateutil.parser.parse(self.due_at)

    @due.setter
    def due(self, due):
        if due:
            self.due_at = due

    @property
    def organization(self):
        """
        |  Comment: The organization of the requester
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def requester(self):
        """
        |  Comment: The id of the requester
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)

    @requester.setter
    def requester(self, requester):
        if requester:
            self.requester_id = requester.id
            self._requester = requester

    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Response(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 comment=None,
                 delivered_at=None,
                 delivery_id=None,
                 id=None,
                 rated_at=None,
                 rating=None,
                 recipient_id=None,
                 survey_id=None,
                 survey_name=None,
                 user_email=None,
                 user_id=None,
                 user_name=None,
                 **kwargs):

        self.api = api
        self.comment = comment
        self.delivered_at = delivered_at
        self.delivery_id = delivery_id
        self.id = id
        self.rated_at = rated_at
        self.rating = rating
        self.recipient_id = recipient_id
        self.survey_id = survey_id
        self.survey_name = survey_name
        self.user_email = user_email
        self.user_id = user_id
        self.user_name = user_name

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def delivered(self):

        if self.delivered_at:
            return dateutil.parser.parse(self.delivered_at)

    @delivered.setter
    def delivered(self, delivered):
        if delivered:
            self.delivered_at = delivered

    @property
    def delivery(self):

        if self.api and self.delivery_id:
            return self.api._get_delivery(self.delivery_id)

    @delivery.setter
    def delivery(self, delivery):
        if delivery:
            self.delivery_id = delivery.id
            self._delivery = delivery

    @property
    def rated(self):

        if self.rated_at:
            return dateutil.parser.parse(self.rated_at)

    @rated.setter
    def rated(self, rated):
        if rated:
            self.rated_at = rated

    @property
    def recipient(self):

        if self.api and self.recipient_id:
            return self.api._get_user(self.recipient_id)

    @recipient.setter
    def recipient(self, recipient):
        if recipient:
            self.recipient_id = recipient.id
            self._recipient = recipient

    @property
    def survey(self):

        if self.api and self.survey_id:
            return self.api._get_survey(self.survey_id)

    @survey.setter
    def survey(self, survey):
        if survey:
            self.survey_id = survey.id
            self._survey = survey

    @property
    def user(self):

        if self.api and self.user_id:
            return self.api._get_user(self.user_id)

    @user.setter
    def user(self, user):
        if user:
            self.user_id = user.id
            self._user = user


class SatisfactionRating(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 assignee_id=None,
                 created_at=None,
                 group_id=None,
                 id=None,
                 requester_id=None,
                 score=None,
                 ticket_id=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: The id of agent assigned to at the time of rating
        # Mandatory: yes
        # Read-only: yes
        # Type: integer
        self.assignee_id = assignee_id

        # Comment: The time the satisfaction rating got created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: The id of group assigned to at the time of rating
        # Mandatory: yes
        # Read-only: yes
        # Type: integer
        self.group_id = group_id

        # Comment: Automatically assigned upon creation
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The id of ticket requester submitting the rating
        # Mandatory: yes
        # Read-only: yes
        # Type: integer
        self.requester_id = requester_id

        # Comment: The rating: "offered", "unoffered", "good" or "bad"
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.score = score

        # Comment: The id of ticket being rated
        # Mandatory: yes
        # Read-only: yes
        # Type: integer
        self.ticket_id = ticket_id

        # Comment: The time the satisfaction rating got updated
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this rating
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def assignee(self):
        """
        |  Comment: The id of agent assigned to at the time of rating
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)

    @assignee.setter
    def assignee(self, assignee):
        if assignee:
            self.assignee_id = assignee.id
            self._assignee = assignee

    @property
    def created(self):
        """
        |  Comment: The time the satisfaction rating got created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def group(self):
        """
        |  Comment: The id of group assigned to at the time of rating
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def requester(self):
        """
        |  Comment: The id of ticket requester submitting the rating
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)

    @requester.setter
    def requester(self, requester):
        if requester:
            self.requester_id = requester.id
            self._requester = requester

    @property
    def ticket(self):
        """
        |  Comment: The id of ticket being rated
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updated(self):
        """
        |  Comment: The time the satisfaction rating got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class SatisfactionRatingEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 assignee_id=None,
                 body=None,
                 id=None,
                 score=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.assignee_id = assignee_id
        self.body = body
        self.id = id
        self.score = score
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def assignee(self):

        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)

    @assignee.setter
    def assignee(self, assignee):
        if assignee:
            self.assignee_id = assignee.id
            self._assignee = assignee


class Schedule(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 id=None,
                 intervals=None,
                 name=None,
                 time_zone=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: Time the schedule was created
        # Type: date
        self.created_at = created_at

        # Comment: Automatically assigned upon creation
        # Type: integer
        self.id = id

        # Comment: Array of intervals for the schedule
        # Type: array
        self.intervals = intervals

        # Comment: Name of the schedule
        # Type: string
        self.name = name

        # Comment: Time zone of the schedule
        # Type: string
        self.time_zone = time_zone

        # Comment: Time the schedule was last updated
        # Type: date
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: Time the schedule was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Comment: Time the schedule was last updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class SharingAgreement(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 id=None,
                 name=None,
                 partner_name=None,
                 remote_subdomain=None,
                 status=None,
                 type=None,
                 **kwargs):

        self.api = api

        # Comment: The time the record was created
        # Type: date
        self.created_at = created_at

        # Comment: Automatically assigned upon creation
        # Type: integer
        self.id = id

        # Comment: Name of this sharing agreement
        # Type: string
        self.name = name

        # Comment: Can be one of the following: 'jira', null
        # Type: string
        self.partner_name = partner_name

        # Comment: Subdomain of the remote account or null if not associated with an account
        # Type: string
        self.remote_subdomain = remote_subdomain

        # Comment: Can be one of the following: 'accepted', 'declined', 'pending', 'inactive'
        # Type: string
        self.status = status

        # Comment: Can be one of the following: 'inbound', 'outbound'
        # Type: string
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created


class Skip(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 id=None,
                 reason=None,
                 ticket=None,
                 ticket_id=None,
                 updated_at=None,
                 user_id=None,
                 **kwargs):

        self.api = api
        self.created_at = created_at
        self.id = id
        self.reason = reason
        self.ticket = ticket
        self.ticket_id = ticket_id
        self.updated_at = updated_at
        self.user_id = user_id

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def user(self):

        if self.api and self.user_id:
            return self.api._get_user(self.user_id)

    @user.setter
    def user(self, user):
        if user:
            self.user_id = user.id
            self._user = user


class SlaPolicy(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created_at=None,
                 description=None,
                 filter=None,
                 id=None,
                 policy_metrics=None,
                 position=None,
                 title=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api
        self.created_at = created_at
        self.description = description
        self.filter = filter
        self.id = id
        self.policy_metrics = policy_metrics
        self.position = position
        self.title = title
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Source(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, from_=None, rel=None, to=None, **kwargs):

        self.api = api
        self.from_ = from_
        self.rel = rel
        self.to = to

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Status(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 action=None,
                 errors=None,
                 id=None,
                 status=None,
                 success=None,
                 title=None,
                 **kwargs):

        self.api = api
        self.action = action
        self.errors = errors
        self.id = id
        self.status = status
        self.success = success
        self.title = title

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class SuspendedTicket(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 author=None,
                 brand_id=None,
                 cause=None,
                 content=None,
                 created_at=None,
                 id=None,
                 recipient=None,
                 subject=None,
                 ticket_id=None,
                 updated_at=None,
                 url=None,
                 via=None,
                 **kwargs):

        self.api = api

        # Comment: The author id (if available), name and email
        # Mandatory: no
        # Read-only: yes
        # Type: object
        self.author = author

        # Comment: The id of the brand this ticket is associated with - only applicable for enterprise accounts
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.brand_id = brand_id

        # Comment: Why the ticket was suspended
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.cause = cause

        # Comment: The content that was flagged
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.content = content

        # Comment: When this record was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: Automatically assigned
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The original recipient e-mail address of the ticket
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.recipient = recipient

        # Comment: The value of the subject field for this ticket
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.subject = subject

        # Comment: The ticket ID this suspended email is associated with, if available
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.ticket_id = ticket_id

        # Comment: When this record last got updated
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this ticket
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        # Comment: This object explains how the ticket was created
        # Mandatory: no
        # Read-only: yes
        # Type: :class:`Via`
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def brand(self):
        """
        |  Comment: The id of the brand this ticket is associated with - only applicable for enterprise accounts
        """
        if self.api and self.brand_id:
            return self.api._get_brand(self.brand_id)

    @brand.setter
    def brand(self, brand):
        if brand:
            self.brand_id = brand.id
            self._brand = brand

    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def ticket(self):
        """
        |  Comment: The ticket ID this suspended email is associated with, if available
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class System(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 client=None,
                 ip_address=None,
                 latitude=None,
                 location=None,
                 longitude=None,
                 **kwargs):

        self.api = api
        self.client = client
        self.ip_address = ip_address
        self.latitude = latitude
        self.location = location
        self.longitude = longitude

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Tag(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, count=None, name=None, **kwargs):

        self.api = api
        self.count = count
        self.name = name

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Target(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 content_type=None,
                 created_at=None,
                 id=None,
                 method=None,
                 password=None,
                 target_url=None,
                 title=None,
                 type=None,
                 url=None,
                 username=None,
                 **kwargs):

        self.api = api

        # Comment: Whether or not the target is activated
        # Mandatory:
        # Type: boolean
        self.active = active
        self.content_type = content_type

        # Comment: The time the target was created
        # Mandatory:
        # Type: date
        self.created_at = created_at

        # Comment: Automatically assigned when created
        # Mandatory:
        # Type: integer
        self.id = id
        self.method = method
        self.password = password
        self.target_url = target_url

        # Comment: A name for the target
        # Mandatory: yes
        # Type: string
        self.title = title

        # Comment: A pre-defined target, such as "basecamp_target". See the additional attributes for the type that follow
        # Mandatory:
        # Type: string
        self.type = type
        self.url = url
        self.username = username

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the target was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created


class Thumbnail(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 content_type=None,
                 content_url=None,
                 file_name=None,
                 id=None,
                 size=None,
                 **kwargs):

        self.api = api
        self.content_type = content_type
        self.content_url = content_url
        self.file_name = file_name
        self.id = id
        self.size = size

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Ticket(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 assignee_id=None,
                 brand_id=None,
                 collaborator_ids=None,
                 created_at=None,
                 custom_fields=None,
                 description=None,
                 due_at=None,
                 external_id=None,
                 fields=None,
                 forum_topic_id=None,
                 group_id=None,
                 has_incidents=None,
                 id=None,
                 organization_id=None,
                 priority=None,
                 problem_id=None,
                 raw_subject=None,
                 recipient=None,
                 requester_id=None,
                 satisfaction_rating=None,
                 sharing_agreement_ids=None,
                 status=None,
                 subject=None,
                 submitter_id=None,
                 tags=None,
                 type=None,
                 updated_at=None,
                 url=None,
                 via=None,
                 **kwargs):

        self.api = api

        # Comment: The agent currently assigned to the ticket
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.assignee_id = assignee_id

        # Comment: Enterprise only. The id of the brand this ticket is associated with
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.brand_id = brand_id

        # Comment: The ids of users currently cc'ed on the ticket
        # Mandatory: no
        # Read-only: no
        # Type: array
        self.collaborator_ids = collaborator_ids

        # Comment: When this record was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: Custom fields for the ticket. See Setting custom field values
        # Mandatory: no
        # Read-only: no
        # Type: array
        self.custom_fields = custom_fields

        # Comment: The first comment on the ticket
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.description = description

        # Comment: If this is a ticket of type "task" it has a due date.  Due date format uses ISO 8601 format.
        # Mandatory: no
        # Read-only: no
        # Type: date
        self.due_at = due_at

        # Comment: An id you can use to link Zendesk Support tickets to local records
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.external_id = external_id
        self.fields = fields

        # Comment: The topic this ticket originated from, if any
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.forum_topic_id = forum_topic_id

        # Comment: The group this ticket is assigned to
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.group_id = group_id

        # Comment: Is true of this ticket has been marked as a problem, false otherwise
        # Mandatory: no
        # Read-only: yes
        # Type: boolean
        self.has_incidents = has_incidents

        # Comment: Automatically assigned when the ticket is created
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The organization of the requester. You can only specify the ID of an organization associated with the requester. See Organization Memberships
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.organization_id = organization_id

        # Comment: The urgency with which the ticket should be addressed. Possible values: "urgent", "high", "normal", "low"
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.priority = priority

        # Comment: For tickets of type "incident", the ID of the problem the incident is linked to
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.problem_id = problem_id

        # Comment: The dynamic content placeholder, if present, or the "subject" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_subject = raw_subject

        # Comment: The original recipient e-mail address of the ticket
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.recipient = recipient

        # Comment: The user who requested this ticket
        # Mandatory: yes
        # Read-only: no
        # Type: integer
        self.requester_id = requester_id

        # Comment: The satisfaction rating of the ticket, if it exists, or the state of satisfaction, 'offered' or 'unoffered'
        # Mandatory: no
        # Read-only: yes
        # Type: object
        self.satisfaction_rating = satisfaction_rating

        # Comment: The ids of the sharing agreements used for this ticket
        # Mandatory: no
        # Read-only: yes
        # Type: array
        self.sharing_agreement_ids = sharing_agreement_ids

        # Comment: The state of the ticket. Possible values: "new", "open", "pending", "hold", "solved", "closed"
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.status = status

        # Comment: The value of the subject field for this ticket
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.subject = subject

        # Comment: The user who submitted the ticket. The submitter always becomes the author of the first comment on the ticket
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.submitter_id = submitter_id

        # Comment: The array of tags applied to this ticket
        # Mandatory: no
        # Read-only: no
        # Type: array
        self.tags = tags

        # Comment: The type of this ticket. Possible values: "problem", "incident", "question" or "task"
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.type = type

        # Comment: When this record last got updated
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The API url of this ticket
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        # Comment: This object explains how the ticket was created
        # Mandatory: no
        # Read-only: yes
        # Type: :class:`Via`
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def assignee(self):
        """
        |  Comment: The agent currently assigned to the ticket
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)

    @assignee.setter
    def assignee(self, assignee):
        if assignee:
            self.assignee_id = assignee.id
            self._assignee = assignee

    @property
    def brand(self):
        """
        |  Comment: Enterprise only. The id of the brand this ticket is associated with
        """
        if self.api and self.brand_id:
            return self.api._get_brand(self.brand_id)

    @brand.setter
    def brand(self, brand):
        if brand:
            self.brand_id = brand.id
            self._brand = brand

    @property
    def collaborators(self):
        """
        |  Comment: The ids of users currently cc'ed on the ticket
        """
        if self.api and self.collaborator_ids:
            return self.api._get_users(self.collaborator_ids)

    @collaborators.setter
    def collaborators(self, collaborators):
        if collaborators:
            self.collaborator_ids = [o.id for o in collaborators]
            self._collaborators = collaborators

    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def due(self):
        """
        |  Comment: If this is a ticket of type "task" it has a due date.  Due date format uses ISO 8601 format.
        """
        if self.due_at:
            return dateutil.parser.parse(self.due_at)

    @due.setter
    def due(self, due):
        if due:
            self.due_at = due

    @property
    def forum_topic(self):
        """
        |  Comment: The topic this ticket originated from, if any
        """
        if self.api and self.forum_topic_id:
            return self.api._get_topic(self.forum_topic_id)

    @forum_topic.setter
    def forum_topic(self, forum_topic):
        if forum_topic:
            self.forum_topic_id = forum_topic.id
            self._forum_topic = forum_topic

    @property
    def group(self):
        """
        |  Comment: The group this ticket is assigned to
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def organization(self):
        """
        |  Comment: The organization of the requester. You can only specify the ID of an organization associated with the requester. See Organization Memberships
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def problem(self):
        """
        |  Comment: For tickets of type "incident", the ID of the problem the incident is linked to
        """
        if self.api and self.problem_id:
            return self.api._get_problem(self.problem_id)

    @problem.setter
    def problem(self, problem):
        if problem:
            self.problem_id = problem.id
            self._problem = problem

    @property
    def requester(self):
        """
        |  Comment: The user who requested this ticket
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)

    @requester.setter
    def requester(self, requester):
        if requester:
            self.requester_id = requester.id
            self._requester = requester

    @property
    def sharing_agreements(self):
        """
        |  Comment: The ids of the sharing agreements used for this ticket
        """
        if self.api and self.sharing_agreement_ids:
            return self.api._get_sharing_agreements(self.sharing_agreement_ids)

    @sharing_agreements.setter
    def sharing_agreements(self, sharing_agreements):
        if sharing_agreements:
            self.sharing_agreement_ids = [o.id for o in sharing_agreements]
            self._sharing_agreements = sharing_agreements

    @property
    def submitter(self):
        """
        |  Comment: The user who submitted the ticket. The submitter always becomes the author of the first comment on the ticket
        """
        if self.api and self.submitter_id:
            return self.api._get_user(self.submitter_id)

    @submitter.setter
    def submitter(self, submitter):
        if submitter:
            self.submitter_id = submitter.id
            self._submitter = submitter

    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class TicketAudit(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, audit=None, ticket=None, **kwargs):

        self.api = api
        self.audit = audit
        self.ticket = ticket

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class TicketEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 child_events=None,
                 id=None,
                 ticket_id=None,
                 timestamp=None,
                 updater_id=None,
                 via=None,
                 **kwargs):

        self.api = api
        self.child_events = child_events
        self.id = id
        self.ticket_id = ticket_id
        self.timestamp = timestamp
        self.updater_id = updater_id
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def ticket(self):

        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updater(self):

        if self.api and self.updater_id:
            return self.api._get_user(self.updater_id)

    @updater.setter
    def updater(self, updater):
        if updater:
            self.updater_id = updater.id
            self._updater = updater


class TicketField(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 collapsed_for_agents=None,
                 created_at=None,
                 description=None,
                 editable_in_portal=None,
                 id=None,
                 position=None,
                 raw_description=None,
                 raw_title=None,
                 raw_title_in_portal=None,
                 regexp_for_validation=None,
                 required=None,
                 required_in_portal=None,
                 tag=None,
                 title=None,
                 title_in_portal=None,
                 type=None,
                 updated_at=None,
                 url=None,
                 visible_in_portal=None,
                 **kwargs):

        self.api = api

        # Comment: Whether this field is available
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.active = active

        # Comment: If this field should be shown to agents by default or be hidden alongside infrequently used fields. Classic interface only
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.collapsed_for_agents = collapsed_for_agents

        # Comment: The time the ticket field was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: The description of the purpose of this ticket field, shown to users
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.description = description

        # Comment: Whether this field is editable by end users
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.editable_in_portal = editable_in_portal

        # Comment: Automatically assigned upon creation
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: A relative position for the ticket fields that determines the order of ticket fields on a ticket. Note that positions 0 to 7 are reserved for system fields
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.position = position

        # Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_description = raw_description

        # Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_title = raw_title

        # Comment: The dynamic content placeholder, if present, or the "title_in_portal" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_title_in_portal = raw_title_in_portal

        # Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.regexp_for_validation = regexp_for_validation

        # Comment: If it's required for this field to have a value when updated by agents
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.required = required

        # Comment: If it's required for this field to have a value when updated by end users
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.required_in_portal = required_in_portal

        # Comment: A tag value to set for checkbox fields when checked
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.tag = tag

        # Comment: The title of the ticket field
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.title = title

        # Comment: The title of the ticket field when shown to end users
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.title_in_portal = title_in_portal

        # Comment: The type of the ticket field: "checkbox", "date", "decimal", "integer", "regexp", "tagger", "text", or "textarea". Type is not editable once created.
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.type = type

        # Comment: The time of the last update of the ticket field
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The URL for this resource
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        # Comment: Whether this field is available to end users
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.visible_in_portal = visible_in_portal

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the ticket field was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the ticket field
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class TicketForm(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 created_at=None,
                 default=None,
                 display_name=None,
                 end_user_visible=None,
                 id=None,
                 in_all_brands=None,
                 in_all_organizations=None,
                 name=None,
                 position=None,
                 raw_display_name=None,
                 raw_name=None,
                 restricted_brand_ids=None,
                 restricted_organization_ids=None,
                 ticket_field_ids=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: If the form is set as active
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.active = active
        self.created_at = created_at

        # Comment: Is the form the default form for this account
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.default = default

        # Comment: The name of the form that is displayed to an end user
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.display_name = display_name

        # Comment: Is the form visible to the end user
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.end_user_visible = end_user_visible
        self.id = id

        # Comment: Is the form available for use in all brands on this account
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.in_all_brands = in_all_brands
        self.in_all_organizations = in_all_organizations

        # Comment: The name of the form
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.name = name

        # Comment: The position of this form among other forms in the account, i.e. dropdown
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.position = position

        # Comment: The dynamic content placeholder, if present, or the "display_name" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_display_name = raw_display_name

        # Comment: The dynamic content placeholder, if present, or the "name" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_name = raw_name

        # Comment: ids of all brands that this ticket form is restricted to
        # Mandatory: no
        # Read-only: yes
        # Type: array
        self.restricted_brand_ids = restricted_brand_ids
        self.restricted_organization_ids = restricted_organization_ids

        # Comment: ids of all ticket fields which are in this ticket form
        # Mandatory: no
        # Read-only: no
        # Type: array
        self.ticket_field_ids = ticket_field_ids
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def restricted_brands(self):
        """
        |  Comment: ids of all brands that this ticket form is restricted to
        """
        if self.api and self.restricted_brand_ids:
            return self.api._get_restricted_brands(self.restricted_brand_ids)

    @restricted_brands.setter
    def restricted_brands(self, restricted_brands):
        if restricted_brands:
            self.restricted_brand_ids = [o.id for o in restricted_brands]
            self._restricted_brands = restricted_brands

    @property
    def restricted_organizations(self):

        if self.api and self.restricted_organization_ids:
            return self.api._get_restricted_organizations(
                self.restricted_organization_ids)

    @restricted_organizations.setter
    def restricted_organizations(self, restricted_organizations):
        if restricted_organizations:
            self.restricted_organization_ids = [
                o.id for o in restricted_organizations
            ]
            self._restricted_organizations = restricted_organizations

    @property
    def ticket_fields(self):
        """
        |  Comment: ids of all ticket fields which are in this ticket form
        """
        if self.api and self.ticket_field_ids:
            return self.api._get_ticket_fields(self.ticket_field_ids)

    @ticket_fields.setter
    def ticket_fields(self, ticket_fields):
        if ticket_fields:
            self.ticket_field_ids = [o.id for o in ticket_fields]
            self._ticket_fields = ticket_fields

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class TicketMetric(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 agent_wait_time_in_minutes=None,
                 assigned_at=None,
                 assignee_stations=None,
                 assignee_updated_at=None,
                 created_at=None,
                 first_resolution_time_in_minutes=None,
                 full_resolution_time_in_minutes=None,
                 group_stations=None,
                 id=None,
                 initially_assigned_at=None,
                 latest_comment_added_at=None,
                 on_hold_time_in_minutes=None,
                 reopens=None,
                 replies=None,
                 reply_time_in_minutes=None,
                 requester_updated_at=None,
                 requester_wait_time_in_minutes=None,
                 solved_at=None,
                 status_updated_at=None,
                 ticket_id=None,
                 updated_at=None,
                 **kwargs):

        self.api = api

        # Comment: Number of minutes the agent spent waiting inside and out of business hours
        # Mandatory: no
        # Read-only: yes
        # Type: object
        self.agent_wait_time_in_minutes = agent_wait_time_in_minutes

        # Comment: When the ticket was last assigned
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.assigned_at = assigned_at

        # Comment: Number of assignees this ticket had
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.assignee_stations = assignee_stations

        # Comment: When the assignee last updated the ticket
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.assignee_updated_at = assignee_updated_at

        # Comment: When this record was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: Number of minutes to the first resolution time inside and out of business hours
        # Mandatory: no
        # Read-only: yes
        # Type: object
        self.first_resolution_time_in_minutes = first_resolution_time_in_minutes

        # Comment: Number of minutes to the full resolution inside and out of business hours
        # Mandatory: no
        # Read-only: yes
        # Type: object
        self.full_resolution_time_in_minutes = full_resolution_time_in_minutes

        # Comment: Number of groups this ticket passed through
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.group_stations = group_stations

        # Comment: Automatically assigned
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: When the ticket was initially assigned
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.initially_assigned_at = initially_assigned_at

        # Comment: When the latest comment was added
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.latest_comment_added_at = latest_comment_added_at
        self.on_hold_time_in_minutes = on_hold_time_in_minutes

        # Comment: Total number of times the ticket was reopened
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.reopens = reopens

        # Comment: Total number of times ticket was replied to
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.replies = replies

        # Comment: Number of minutes to the first reply inside and out of business hours
        # Mandatory: no
        # Read-only: yes
        # Type: object
        self.reply_time_in_minutes = reply_time_in_minutes

        # Comment: When the requester last updated the ticket
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.requester_updated_at = requester_updated_at

        # Comment: Number of minutes the requester spent waiting inside and out of business hours
        # Mandatory: no
        # Read-only: yes
        # Type: object
        self.requester_wait_time_in_minutes = requester_wait_time_in_minutes

        # Comment: When the ticket was solved
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.solved_at = solved_at

        # Comment: When the status was last updated
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.status_updated_at = status_updated_at

        # Comment: Id of the associated ticket
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.ticket_id = ticket_id

        # Comment: When this record last got updated
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def assigned(self):
        """
        |  Comment: When the ticket was last assigned
        """
        if self.assigned_at:
            return dateutil.parser.parse(self.assigned_at)

    @assigned.setter
    def assigned(self, assigned):
        if assigned:
            self.assigned_at = assigned

    @property
    def assignee_updated(self):
        """
        |  Comment: When the assignee last updated the ticket
        """
        if self.assignee_updated_at:
            return dateutil.parser.parse(self.assignee_updated_at)

    @assignee_updated.setter
    def assignee_updated(self, assignee_updated):
        if assignee_updated:
            self.assignee_updated_at = assignee_updated

    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def initially_assigned(self):
        """
        |  Comment: When the ticket was initially assigned
        """
        if self.initially_assigned_at:
            return dateutil.parser.parse(self.initially_assigned_at)

    @initially_assigned.setter
    def initially_assigned(self, initially_assigned):
        if initially_assigned:
            self.initially_assigned_at = initially_assigned

    @property
    def latest_comment_added(self):
        """
        |  Comment: When the latest comment was added
        """
        if self.latest_comment_added_at:
            return dateutil.parser.parse(self.latest_comment_added_at)

    @latest_comment_added.setter
    def latest_comment_added(self, latest_comment_added):
        if latest_comment_added:
            self.latest_comment_added_at = latest_comment_added

    @property
    def requester_updated(self):
        """
        |  Comment: When the requester last updated the ticket
        """
        if self.requester_updated_at:
            return dateutil.parser.parse(self.requester_updated_at)

    @requester_updated.setter
    def requester_updated(self, requester_updated):
        if requester_updated:
            self.requester_updated_at = requester_updated

    @property
    def solved(self):
        """
        |  Comment: When the ticket was solved
        """
        if self.solved_at:
            return dateutil.parser.parse(self.solved_at)

    @solved.setter
    def solved(self, solved):
        if solved:
            self.solved_at = solved

    @property
    def status_updated(self):
        """
        |  Comment: When the status was last updated
        """
        if self.status_updated_at:
            return dateutil.parser.parse(self.status_updated_at)

    @status_updated.setter
    def status_updated(self, status_updated):
        if status_updated:
            self.status_updated_at = status_updated

    @property
    def ticket(self):
        """
        |  Comment: Id of the associated ticket
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class TicketMetricEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 deleted=None,
                 id=None,
                 instance_id=None,
                 metric=None,
                 sla=None,
                 status=None,
                 ticket_id=None,
                 time=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.deleted = deleted

        # Comment: Automatically assigned when the record is created
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The instance of the metric associated with the event. See instance_id
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.instance_id = instance_id

        # Comment: One of the following: agent_work_time, pausable_update_time, periodic_update_time, reply_time, requester_wait_time, or resolution_time
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.metric = metric
        self.sla = sla
        self.status = status

        # Comment: Id of the associated ticket
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.ticket_id = ticket_id

        # Comment: The time the event occurred
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.time = time

        # Comment: One of the following: activate, pause, fulfill, apply_sla, breach, or update_status. See Metric event types
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def ticket(self):
        """
        |  Comment: Id of the associated ticket
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket


class TicketMetricItem(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, business=None, calendar=None, **kwargs):

        self.api = api
        self.business = business
        self.calendar = calendar

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class TicketSharingEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 action=None,
                 agreement_id=None,
                 id=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.action = action
        self.agreement_id = agreement_id
        self.id = id
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Topic(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 body=None,
                 created_at=None,
                 forum_id=None,
                 id=None,
                 locked=None,
                 pinned=None,
                 position=None,
                 search_phrases=None,
                 submitter_id=None,
                 tags=None,
                 title=None,
                 topic_type=None,
                 updated_at=None,
                 updater_id=None,
                 url=None,
                 **kwargs):

        self.api = api
        self.body = body
        self.created_at = created_at
        self.forum_id = forum_id
        self.id = id
        self.locked = locked
        self.pinned = pinned
        self.position = position
        self.search_phrases = search_phrases
        self.submitter_id = submitter_id
        self.tags = tags
        self.title = title
        self.topic_type = topic_type
        self.updated_at = updated_at
        self.updater_id = updater_id
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def forum(self):

        if self.api and self.forum_id:
            return self.api._get_forum(self.forum_id)

    @forum.setter
    def forum(self, forum):
        if forum:
            self.forum_id = forum.id
            self._forum = forum

    @property
    def submitter(self):

        if self.api and self.submitter_id:
            return self.api._get_user(self.submitter_id)

    @submitter.setter
    def submitter(self, submitter):
        if submitter:
            self.submitter_id = submitter.id
            self._submitter = submitter

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def updater(self):

        if self.api and self.updater_id:
            return self.api._get_user(self.updater_id)

    @updater.setter
    def updater(self, updater):
        if updater:
            self.updater_id = updater.id
            self._updater = updater


class Trigger(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 actions=None,
                 active=None,
                 conditions=None,
                 description=None,
                 id=None,
                 position=None,
                 title=None,
                 **kwargs):

        self.api = api

        # Comment: An array of Actions describing what the trigger will do
        # Type: array
        self.actions = actions

        # Comment: Whether the trigger is active
        # Type: boolean
        self.active = active

        # Comment: An object that describes the conditions under which the trigger will execute
        # Type: :class:`Conditions`
        self.conditions = conditions

        # Comment: The description of the trigger
        # Type: string
        self.description = description

        # Comment: Automatically assigned when created
        # Type: integer
        self.id = id

        # Comment: Position of the trigger, determines the order they will execute in
        # Type: integer
        self.position = position

        # Comment: The title of the trigger
        # Type: string
        self.title = title

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class TweetEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 body=None,
                 direct_message=None,
                 id=None,
                 recipients=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.body = body
        self.direct_message = direct_message
        self.id = id
        self.recipients = recipients
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Upload(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 attachment=None,
                 attachments=None,
                 expires_at=None,
                 token=None,
                 **kwargs):

        self.api = api
        self.attachment = attachment
        self.attachments = attachments
        self.expires_at = expires_at
        self.token = token

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def expires(self):

        if self.expires_at:
            return dateutil.parser.parse(self.expires_at)

    @expires.setter
    def expires(self, expires):
        if expires:
            self.expires_at = expires


class User(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 alias=None,
                 chat_only=None,
                 created_at=None,
                 custom_role_id=None,
                 details=None,
                 email=None,
                 external_id=None,
                 id=None,
                 last_login_at=None,
                 locale=None,
                 locale_id=None,
                 moderator=None,
                 name=None,
                 notes=None,
                 only_private_comments=None,
                 organization_id=None,
                 phone=None,
                 photo=None,
                 restricted_agent=None,
                 role=None,
                 shared=None,
                 shared_agent=None,
                 signature=None,
                 suspended=None,
                 tags=None,
                 ticket_restriction=None,
                 time_zone=None,
                 two_factor_auth_enabled=None,
                 updated_at=None,
                 url=None,
                 user_fields=None,
                 verified=None,
                 **kwargs):

        self.api = api

        # Comment: false if the user has been deleted
        # Mandatory: no
        # Read-only: yes
        # Type: boolean
        self.active = active

        # Comment: An alias displayed to end users
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.alias = alias

        # Comment: Whether or not the user is a chat-only agent
        # Mandatory: no
        # Read-only: yes
        # Type: boolean
        self.chat_only = chat_only

        # Comment: The time the user was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: A custom role if the user is an agent on the Enterprise plan
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.custom_role_id = custom_role_id

        # Comment: Any details you want to store about the user, such as an address
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.details = details

        # Comment: The user's primary email address. Writeable on create only. On update, a secondary email is added. See Email Address
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.email = email

        # Comment: A unique identifier from another system. The API treats the id as case insensitive. Example: ian1 and Ian1 are the same user
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.external_id = external_id

        # Comment: Automatically assigned when the user is created
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The last time the user signed in to Zendesk Support
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.last_login_at = last_login_at

        # Comment: The user's locale
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.locale = locale

        # Comment: The user's language identifier
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.locale_id = locale_id

        # Comment: Designates whether the user has forum moderation capabilities
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.moderator = moderator

        # Comment: The user's name
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.name = name

        # Comment: Any notes you want to store about the user
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.notes = notes

        # Comment: true if the user can only create private comments
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.only_private_comments = only_private_comments

        # Comment: The id of the organization the user is associated with
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.organization_id = organization_id

        # Comment: The user's primary phone number. See Phone Number below
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.phone = phone

        # Comment: The user's profile picture represented as an Attachment object
        # Mandatory: no
        # Read-only: no
        # Type: :class:`Attachment`
        self.photo = photo

        # Comment: If the agent has any restrictions; false for admins and unrestricted agents, true for other agents
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.restricted_agent = restricted_agent

        # Comment: The user's role. Possible values are "end-user", "agent", or "admin"
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.role = role

        # Comment: If the user is shared from a different Zendesk Support instance. Ticket sharing accounts only
        # Mandatory: no
        # Read-only: yes
        # Type: boolean
        self.shared = shared

        # Comment: If the user is a shared agent from a different Zendesk Support instance. Ticket sharing accounts only
        # Mandatory: no
        # Read-only: yes
        # Type: boolean
        self.shared_agent = shared_agent

        # Comment: The user's signature. Only agents and admins can have signatures
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.signature = signature

        # Comment: If the agent is suspended. Tickets from suspended users are also suspended, and these users cannot sign in to the end user portal
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.suspended = suspended

        # Comment: The user's tags. Only present if your account has user tagging enabled
        # Mandatory: no
        # Read-only: no
        # Type: array
        self.tags = tags

        # Comment: Specifies which tickets the user has access to. Possible values are: "organization", "groups", "assigned", "requested", null
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.ticket_restriction = ticket_restriction

        # Comment: The user's time zone. See Time Zone
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.time_zone = time_zone

        # Comment: If two factor authentication is enabled.
        # Mandatory: no
        # Read-only: yes
        # Type: boolean
        self.two_factor_auth_enabled = two_factor_auth_enabled

        # Comment: The time the user was last updated
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The user's API url
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        # Comment: Values of custom fields in the user's profile. See User Fields
        # Mandatory: no
        # Read-only: no
        # Type: object
        self.user_fields = user_fields

        # Comment: The user's primary identity is verified or not. For secondary identities, see User Identities
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.verified = verified

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the user was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def custom_role(self):
        """
        |  Comment: A custom role if the user is an agent on the Enterprise plan
        """
        if self.api and self.custom_role_id:
            return self.api._get_custom_role(self.custom_role_id)

    @custom_role.setter
    def custom_role(self, custom_role):
        if custom_role:
            self.custom_role_id = custom_role.id
            self._custom_role = custom_role

    @property
    def last_login(self):
        """
        |  Comment: The last time the user signed in to Zendesk Support
        """
        if self.last_login_at:
            return dateutil.parser.parse(self.last_login_at)

    @last_login.setter
    def last_login(self, last_login):
        if last_login:
            self.last_login_at = last_login

    @property
    def organization(self):
        """
        |  Comment: The id of the organization the user is associated with
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def updated(self):
        """
        |  Comment: The time the user was last updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class UserField(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 created_at=None,
                 description=None,
                 id=None,
                 key=None,
                 position=None,
                 raw_description=None,
                 raw_title=None,
                 regexp_for_validation=None,
                 title=None,
                 type=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: If true, this field is available for use
        # Mandatory: no
        # Read-only: no
        # Type: boolean
        self.active = active

        # Comment: The time the ticket field was created
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: User-defined description of this field's purpose
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.description = description

        # Comment: Automatically assigned upon creation
        # Mandatory: no
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders.
        # Mandatory: on create
        # Read-only: no
        # Type: string
        self.key = key

        # Comment: Ordering of the field relative to other fields
        # Mandatory: no
        # Read-only: no
        # Type: integer
        self.position = position

        # Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_description = raw_description

        # Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.raw_title = raw_title

        # Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        # Mandatory: no
        # Read-only: no
        # Type: string
        self.regexp_for_validation = regexp_for_validation

        # Comment: The title of the custom field
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.title = title

        # Comment: Type of the custom field: "checkbox", "date", "decimal", "dropdown", "integer", "regexp", "text", or "textarea"
        # Mandatory: yes
        # Read-only: no
        # Type: string
        self.type = type

        # Comment: The time of the last update of the ticket field
        # Mandatory: no
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at

        # Comment: The URL for this resource
        # Mandatory: no
        # Read-only: yes
        # Type: string
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the ticket field was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the ticket field
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class UserRelated(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 assigned_tickets=None,
                 ccd_tickets=None,
                 entry_subscriptions=None,
                 forum_subscriptions=None,
                 organization_subscriptions=None,
                 requested_tickets=None,
                 subscriptions=None,
                 topic_comments=None,
                 topics=None,
                 votes=None,
                 **kwargs):

        self.api = api
        self.assigned_tickets = assigned_tickets
        self.ccd_tickets = ccd_tickets
        self.entry_subscriptions = entry_subscriptions
        self.forum_subscriptions = forum_subscriptions
        self.organization_subscriptions = organization_subscriptions
        self.requested_tickets = requested_tickets
        self.subscriptions = subscriptions
        self.topic_comments = topic_comments
        self.topics = topics
        self.votes = votes

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class Variant(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 content=None,
                 created_at=None,
                 default=None,
                 id=None,
                 locale_id=None,
                 outdated=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api
        self.active = active
        self.content = content
        self.created_at = created_at
        self.default = default
        self.id = id
        self.locale_id = locale_id
        self.outdated = outdated
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Via(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self, api=None, source=None, **kwargs):

        self.api = api
        self.source = source

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue


class View(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 active=None,
                 conditions=None,
                 created_at=None,
                 execution=None,
                 id=None,
                 position=None,
                 raw_title=None,
                 restriction=None,
                 sla_id=None,
                 title=None,
                 updated_at=None,
                 url=None,
                 **kwargs):

        self.api = api

        # Comment: Whether the view is active
        # Read-only: no
        # Type: boolean
        self.active = active

        # Comment: An object describing how the view is constructed
        # Read-only: no
        # Type: :class:`Conditions`
        self.conditions = conditions

        # Comment: The time the view was created
        # Read-only: yes
        # Type: date
        self.created_at = created_at

        # Comment: An object describing how the view should be executed
        # Read-only: no
        # Type: :class:`Execute`
        self.execution = execution

        # Comment: Automatically assigned when created
        # Read-only: yes
        # Type: integer
        self.id = id

        # Comment: The position of the view
        # Read-only: no
        # Type: integer
        self.position = position
        self.raw_title = raw_title

        # Comment: Who may access this account. Will be null when everyone in the account can access it.
        # Read-only: no
        # Type: object
        self.restriction = restriction
        self.sla_id = sla_id

        # Comment: The title of the view
        # Read-only: no
        # Type: string
        self.title = title

        # Comment: The time of the last update of the view
        # Read-only: yes
        # Type: date
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def created(self):
        """
        |  Comment: The time the view was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def sla(self):

        if self.api and self.sla_id:
            return self.api._get_sla(self.sla_id)

    @sla.setter
    def sla(self, sla):
        if sla:
            self.sla_id = sla.id
            self._sla = sla

    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the view
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class ViewCount(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 channel=None,
                 fresh=None,
                 poll_wait=None,
                 pretty=None,
                 refresh=None,
                 url=None,
                 value=None,
                 view_id=None,
                 **kwargs):

        self.api = api
        self.channel = channel
        self.fresh = fresh
        self.poll_wait = poll_wait
        self.pretty = pretty
        self.refresh = refresh
        self.url = url
        self.value = value
        self.view_id = view_id

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def view(self):

        if self.api and self.view_id:
            return self.api._get_view(self.view_id)

    @view.setter
    def view(self, view):
        if view:
            self.view_id = view.id
            self._view = view


class ViewRow(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 created=None,
                 custom_fields=None,
                 fields=None,
                 group_id=None,
                 priority=None,
                 requester_id=None,
                 score=None,
                 subject=None,
                 ticket=None,
                 **kwargs):

        self.api = api
        self.created = created
        self.custom_fields = custom_fields
        self.fields = fields
        self.group_id = group_id
        self.priority = priority
        self.requester_id = requester_id
        self.score = score
        self.subject = subject
        self.ticket = ticket

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def group(self):

        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def requester(self):

        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)

    @requester.setter
    def requester(self, requester):
        if requester:
            self.requester_id = requester.id
            self._requester = requester


class VoiceCommentEvent(BaseObject):
    """
    ######################################################################
    #    Do not modify, this class is autogenerated by gen_classes.py    #
    ######################################################################
    """
    def __init__(self,
                 api=None,
                 attachments=None,
                 author_id=None,
                 body=None,
                 data=None,
                 formatted_from=None,
                 formatted_to=None,
                 html_body=None,
                 id=None,
                 public=None,
                 transcription_visible=None,
                 trusted=None,
                 type=None,
                 **kwargs):

        self.api = api
        self.attachments = attachments
        self.author_id = author_id
        self.body = body
        self.data = data
        self.formatted_from = formatted_from
        self.formatted_to = formatted_to
        self.html_body = html_body
        self.id = id
        self.public = public
        self.transcription_visible = transcription_visible
        self.trusted = trusted
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

        for key in self.to_dict():
            if getattr(self, key) is None:
                try:
                    self._dirty_attributes.remove(key)
                except KeyError:
                    continue

    @property
    def author(self):

        if self.api and self.author_id:
            return self.api._get_user(self.author_id)

    @author.setter
    def author(self, author):
        if author:
            self.author_id = author.id
            self._author = author
